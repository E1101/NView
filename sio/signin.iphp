<?php
mb_internal_encoding('UTF-8');

/**
 * class 'SioSignIn'
 */
class SioSignIn {
	use Form;
	const SIG = "siosignin_";
	public static function sig() { return static::SIG; }
	private static $v=array("siosignin_" => "siosignin_v.ixml");
	public static::$field_keys = array(
		'siosignin_prompt_username',
		'siosignin_prompt_password',
		'siosignin_button_signin',
		'siosignin_button_forgot',
		'siosignin_button_register'
	);
	public static function initialise() {
		$en = array(
			static::SIG .'prompt_username' => "Username",
			static::SIG .'prompt_password'=>"Password",
			static::SIG .'button_signin'=>"Sign In",
			static::SIG .'button_forgot'=>"Forgot Password",
			static::SIG .'button_register'=>"Register"
			static::SIG .'errors_username_unmatched'=>"Either the username or password don't match our records",
			static::SIG .'errors_username_empty'=>"You need to enter your username"
		);
		$gr = array(
			static::SIG .'prompt_username' => "Όνομα Χρήστη",
			static::SIG .'prompt_password'=>"Κωδικός",
			static::SIG .'button_signin'=>"Είσοδος",
			static::SIG .'button_forgot'=>"Ξέχασα τον κωδικό μου",
			static::SIG .'button_register'=>"Εγγραφή"
			static::SIG .'errors_username_unmatched'=>"Το όνομα χρήστη ή ο κωδικός δεν ειναι σωστά"
		);
		Dict::set($en,'en');
		Dict::set($gr,'gr');
	}

/**
 * '__construct'
 */
	function __construct($key=NULL,$custom_views=array()) {
		static::$v = array_replace(static::$v,$custom_views);
		$this->iniForm($key,@static::$v[static::SIG]);
		$this->key=$key;
		$this->table="user";
		$this->setfld('username');
		$this->setfld('password');	
	}

/**
 * 'ident'
 *  This overrides the standard ident - we don't want to check usr value for signin.
 */
	private function ident() {
		return md5($this->signature);
	}

/**
 * 'validate'
 * fn fulfilling form trait func, which deals with different button presses.
 * These are set by values in the buttons on the view.
 * fn 'save' - the default action - is handled higher up.
 */
	protected function func() {
		switch ($this->fields['_fn'][0]) {
			case 'forgot': {
				$sf=new SIOForgot(NULL,static::$v);
				return $sf->form();
			} break;
			case 'register': {
				$sf=new SIOReg(NULL,static::$v);
				return $sf->form();
			} break;
		}
	}
/**
 * 'validate'
 * fn fulfilling abstract requirement of trait 'Form'.
 * validate all fields in this->fields.
 * errors are placed into the this->view.
 */
	protected function validate() {
		$retval = false;
		if (isset($this->fields['username'][0]) && isset($this->fields['password'][0])) {
			$un=$this->fields['username'][0];
			$ph=hash('sha256',$un . hex2bin('5BE0BDA8E0BDBCE0BDBEE0BC8BE0BDA7E0BDB1E0BDB4E0BDBE5D') . hash('sha256',$this->fields['password'][0]));
			$this->fields['password'][0]='';
			$qry="select count(id) as ok from " . $this->table . " where active='on' and username='" .$un. "' and password='" . $ph . "'";
			if ($rx = Settings::$sql->query($qry)) {
				if (strcmp($rx->fetch_row()[0],"1") === 0) {
					$retval=true;
				} else {
					$this->seterr("username",Dict::get(static::SIG.'errors_username_unmatched'));
				}
				$rx->close();
			}
		} else {
			$this->seterr("username",Dict::get(static::SIG.'errors_username_empty'));
		}
		$this->valid = $retval;
	}

/**
 * 'commit'
 * fn OVERLOADING trait 'Form'.
 */
	protected function commit() {
		Session::set('username',$this->fields['username'][0]);
		Settings::usr();
		return true;
	}

/**
 * 'populate'
 * fn fulfilling abstract requirement of trait 'Form'.
 * place this->fields array into view.
 */
	protected function populate() {
		$this->vset('username');
		$this->tset(static::$field_keys);
	}

}
